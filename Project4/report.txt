1.) I didn't finish the findRelatedGenomes function, so it doesn't work at all

2.) My addGenome function does not satisfy the big-O requirement. My addGenome makes approximately N calls to insert a string of length m_minSearchLength. Inserting into my trie takes about L*C steps where L is the m_minSearchLength and C is the average number of children per node, so the total big-O is N*L*C.

My findRelatedGenomes runs in I believe Q*X*logM time where M is the number of matches returned from findGenomesWithThisDNA, although the function doesn't actually work properly.

3.)

Find - input: a string we are searching for S, and a bool telling if we want only exact matches B
also, findHelper, a recursive function that helps find - input: bool B, string S, Node* current

start at the root

for each child on my current node
	if this child's label is the same as my first letter
		use a magic function(recursion!!) to check the next letters, and add any matches to a vector
	insert any new matches to our current vector of matches
return matches


findHelper:

if our string is empty
	return values in current node
for each child in current node
	if child's label is the same as our first letter
		run this function taking out our first letter and advancing to this child
	else if we allow mismatches
		run this function taking out our first letter and declaring we wont allow any more matches 
		and advancing to this child

	insert any new matches into our current matches

return matches


findGenomesWithThisDNA - input : string F, int minLength, bool exactMatchOnly, vector<DNAMatch> matches

find possible genomes that would match with the first m_minSearchLength characters in fragment

for each possible genome
	extract from position of match string same length as fragment
	determine length until mismatch or two mismatches if not exactMatchOnly
	
	if we have not found a match on this genome yet
		make a DNAMatch with name, position equal to tihs current DNAStrand's
		set DNAMatch's length to length of this match
		map this genome to this DNAMatch
	else
		if this match's length is longer than previous matches found on this genome
			set the mapped DNAMatch's position and length to this position and length
		else if this match's length is equal to previous matches found on this genome
			set mapped DNAMatch's position to the minimum of the two positions

for each genome in the map
	if the mapped DNAMatch's length is at least as long as the minimum length
		push_back the DNAMatch onto matches

return (matches contains something)

