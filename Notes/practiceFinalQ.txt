int countFront(queue<char>& q)
{
	if (q.empty())
		return 0;
	int front = q.front();
	q.pop();
	int count = 1;
	while(!q.empty())
	{
		
		if(q.front() == front)
			count++;	
		q.pop();

	}



}

int countTop(stack<char>& s)
{
	if (s.empty())
		return 0;
	stack<char> temp;
	char top = s.top();
	int count = 0;
	while (!s.empty())
	{
		temp.push(s.top());
		if (s.top() == top)
			count++;
		s.pop();
	}

	while (!temp.empty())
	{
		s.push(temp.top());
		temp.pop();
	}
	return count;

}

Node *addOp(Node *root, char op, char digit)
{
	Node* right = new Node(digit, NULL, NULL);
	Node* operator = new Node(op, root, right);
	return operator;

}


int evaluate(Node *root)
{
	if (root == nullptr)
		return 0;
	if (isdigit(root->val))
		return root->val;
	int left = evaluate(root->left);
	int right = evaluate(root->right);
	
	switch(root->val)
	{
	case '+':
		return left + right;
	case '-':
		return left - right;
	case '*':
		return left* right;
	case '/':
		return left/right;
	}
	return 0;
	



}




int findPos(int a[], int size, int target)
{

	int mid = size/2;

	if (a[mid] == target;
	{
		return mid;
	}
	else if (target < a[mid])
		return findPos(a, size/2, target);
	else
		return mid + findPos(a+size/2+1, (size+1)/2, target);
}

	
Node* recursiveMerge(Node* cur1, Node* cur2)
{
	if (cur1 == nullptr || cur2 == nullptr)
		return nullptr;
	
	if (cur1->val < cur2->val)
	{
		recursiveMerge(cur1->next, cur2);
		cur1->next = cur2;
		return cur1;
	}
	else
	{
		recursiveMerge(cur1, cur2->next);
		cur2->next = cur1;
		return cur2;
	}
	


}



int maxDepth(Node* root)
{
	if (root == nullptr)
		return 0;
	return 1 + max(maxDepth(root->left), maxDepth(root->right));

}

bool containsDuplicates(string s)
{
	unordered<char, bool> hasBeenFound;
	for (int i = 0; i < s.size(); i++)
	{
		if (hasBeenFound.find(s[i]))
			return true;
		hasBeenFound[s[i]] = true;

	}
	return false;
}


void printCommonValues()
{
	hashmap<int, bool> isPresent;

	for (int i = 0; i < len1; i++)
		isPresent[arr1[i]] = true;
	for (int i = 0; i < len2; i++)
		if (isPresent[arr2[i])
			cout << arr2[i];
	
}		.
	
			.		.
		    .        .       .       

				